---
title: "클라우드 네이티브 아키텍처의 10가지 기본 패턴"
description: ""
coverImage: "/assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_0.png"
date: 2024-07-30 16:49
ogImage: 
  url: /assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_0.png
tag: Tech
originalTitle: "10 Fundamental Cloud-Native Architecture Patterns"
link: "https://medium.com/@azeynalli1990/10-fundamental-cloud-native-architecture-patterns-8a4c4a34b721"
---


<img src="/assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_0.png" />

클라우드 네이티브 환경에서 빌드된 애플리케이션에서는 소프트웨어 아키텍처가 약간 다른 접근 방식을 취할 수 있습니다. 이러한 애플리케이션은 대부분 마이크로서비스 형태로 구축됩니다. 그 외에도 이러한 애플리케이션은 클라우드 컴퓨팅 모델을 활용하기 위해 동적으로 조정되고 컨테이너화된 환경에서 작동할 수 있어야 합니다.

클라우드 환경에서 소프트웨어 아키텍처의 동기는 특히 컨테이너에서 소프트웨어 구성 요소를 모듈화하기 위한 관심사의 분리에 있습니다. 다음 패턴들이 이러한 목적을 달성하는 데 도움이 됩니다.

1. Sidecar/Sidekick...

<div class="content-ad"></div>

이 패턴은 주요 응용 프로그램의 주변 부분을 다른 마이크로서비스로 추상화하고 싶을 때 도움이 됩니다. 이는 서비스 간에 독립성을 유지하고 서로 강하게 결합된 구성 요소를 분리하는 데 도움이 됩니다.

Sidecar / Sidekick 패턴은 같은 언어와 라이브러리를 사용하는 응용 프로그램에서 라이프사이클을 공유하지만 독립적으로 배포할 수 있는 서비스가 필요한 경우 유용한 선택입니다. 각 인스턴스에 대해 사이드카 서비스를 배포하는 비용이 격리의 이점에 비해 가치가 없다면 Sidecar/Sidekick 패턴을 적용하는 것은 나쁜 결정일 수 있습니다. 로깅, 구성 등과 같은 기능은 아래 예시와 같이 다른 마이크로서비스로 추상화할 수 있습니다. 이 패턴은 주요 서비스와 1:1 관계를 갖습니다.

![이미지](/assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_1.png)

2.대사…



<div class="content-ad"></div>

대사관 패턴은 특히 서비스가 오래되거나 수정하기에 충분히 복잡한 경우에 기존 서비스의 네트워크 기능을 확장하는 데 자주 사용됩니다.

이 패턴을 통해 추가적인 프록시를 추가하면 대기 시간이 발생합니다. 이 패턴은 Sidecar와 달리 여러 서비스에 사용할 수 있습니다. 이 패턴은 레거시 서비스의 연결 기능을 향상시키는 데 도움이 될 수 있습니다. 그러나 대사관 패턴은 프록시 오버헤드를 가지고 있기 때문에 저렴한 대기 시간이 중요한 경우에는 적합하지 않습니다.

![이미지](/assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_2.png)

3. Scatter/Gather...

<div class="content-ad"></div>

이 패턴은 레거시 응용 프로그램에서 중복 서비스를 사용하는 경우에 사용됩니다. 이 패턴의 주요 아이디어는 다른 서비스로부터의 응답을 요약하고 최상의 견적을 제공하는 집계자를 가지는 것입니다. 이 패턴은 모든 마이크로서비스로의 메시지 흐름을 효과적으로 제어하는 데 좋습니다.

![image](/assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_3.png)

4. 프론트엔드를 위한 백엔드...

이 패턴의 주요 요지는 프론트엏으 백엔드 사이에 또 다른 백엔드 계층을 만드는 것입니다. 이를 백엔드 대 프론트엔드라고 부릅니다. 이것은 산업 전반에서 광범위하게 적용되는 가장 인기 있는 패턴 중 하나입니다. 이러한 추가 계층을 추가함으로써 다른 프론트엏 백엔드 서버 간의 오케스트레이션, 프론트엔드에서 온 응답을 유효성 검사하고 필터링하며, 백엔드에서 전달되는 데이터 모델을 매핑하고 변환할 수 있습니다.

<div class="content-ad"></div>

![이미지](/assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_4.png)

5. 안티-코럽션 레이어...

이 패턴은 서로 다른 서브시스템이나 마이크로서비스 간에 동일한 의미를 공유하지 않는 경우 매우 유용할 수 있습니다. 안티-코럽션 레이어는 서비스 간 통신을 번역하거나 통합합니다. 이 패턴은 처음에 도메인 주도 설계의 Eric Evans가 설명했습니다.

이러한 형태의 조합은 레거시 시스템을 새 시스템으로 이관 중이거나 새 시스템이 레거시 시스템의 리소스나 기능을 사용하는 상황에서 매우 발생할 수 있습니다.

<div class="content-ad"></div>

다음은 단점과 부작용일 수 있습니다:

- 이 추가 레이어는 더 많은 지연을 일으킵니다.
- 이 레이어는 추가 서비스이기도 하며 리소스를 차지할 것입니다.
- 유지 보수성, 데이터 일관성, 자동 확장 및 연결 서비스 비용에 대해서도 추가로 주의가 필요합니다.

![이미지](/assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_5.png)

6. 명령 및 쿼리 책임 분리...

<div class="content-ad"></div>

이 패턴은 데이터베이스 읽기 및 업데이트에 대한 관심사 분리(SoC: Separation of Concerns)를 기반으로 합니다. 전통적인 아키텍쳐에서 데이터 복잡성 문제는 읽기가 많은 쿼리를 수행하고 쓰기가 매우 복잡한 유효성 검사 및 비즈니스 로직을 구현하는 경우에 나타납니다. 이러한 읽기 및 쓰기는 서로 비대칭이며 성능과 요구 사항이 다릅니다.

여기에 제안된 해결책은 CQRS(명령과 조회의 책임 분리)로, 이는 읽기와 쓰기를 서로 다른 구성 요소로 분리합니다:

- 명령은 작업 기반 이어야 합니다 ("호텔 객실 예약", "예약 상태를 예약으로 설정"이 아니어야 함).
- 명령은 비동기 통신을 통해 구현됩니다.
- 쿼리는 데이터베이스를 변경하지 않습니다. 쿼리는 비즈니스 로직을 포함하지 않는 DTO로 응답합니다.

이 패턴의 한 가지 단점은 읽기 및 쓰기 구성 요소를 동기화하는 것입니다.

<div class="content-ad"></div>


![이미지](/assets/img/2024-07-30-10FundamentalCloud-NativeArchitecturePatterns_6.png)

7. 이벤트 소싱...

이벤트 소싱 패턴은 마지막 10년 동안 인기 있는 기술 중 하나로, CRUD 응용 프로그램이 일관성을 잃는 경우에 사용됩니다. 전통적인 CRUD 응용 프로그램과 달리 현재 상태를 저장하는 것이 아니라 데이터를 추가만 하는 방식으로 저장하여 데이터에 수행된 모든 작업의 시퀀스를 저장하는 것이 이벤트 소싱의 주된 아이디어입니다. 이는 트랜잭션 데이터에 대한 일관성을 제공하며 편집 기록의 전체 감사 통제를 유지합니다.

장점:


<div class="content-ad"></div>

- 강력한 데이터 일관성을 허용하여 성능을 향상시킵니다
- 이벤트 스토어를 사용하여 데이터 편집을 간단하고 쉽게 구현 및 관리할 수 있습니다
- 이벤트는 도메인 전문가들이 읽을 수 있어 개발자뿐만 아니라 이해하기 쉽게 만듭니다
- 같은 데이터에 대한 동시 업데이트를 방지하며 이벤트의 연대순입니다
- 데이터 조작의 단일 소스로서의 이벤트 스토어

단점:

- 작은 도메인 응용 프로그램에 대한 초 엔지니어링으로 간주됩니다
- 실시간 데이터 기반 응용프로그램에는 적합하지 않습니다

8. Service Mesh...

<div class="content-ad"></div>

주요 아이디어는 통신, 모니터링, 보안, 인증/인가 등과 같은 응용 프로그램 독립적인 교차 관심사를 핵심 비즈니스 로직에서 분리하는 것입니다. 이러한 전용 인프라 레이어는 낮은 대기 시간, 구성 가능성에 가치를 추가합니다.
인증/권한 부여 외에도, 서비스 검색, 서비스 메시 패턴은 다음과 같은 다른 중요한 기능을 제공합니다:

- 회로 차단
- 속도 제한
- 조건부 속도 제한
- 트래픽 이동

9. 멍청한-똑똑한 구성요소(프론트엔드 중심)...

<div class="content-ad"></div>

SoC가 시작한 다음 패턴입니다. 여기에는 프레젠테이션 전용인 덤 컴포넌트와 데이터 흐름을 담당하는 스마트 컴포넌트 두 가지 종류의 컴포넌트가 있습니다. 이러한 분리는 주로 덤 컴포넌트 내에서 @Input, @Output (EventEmitter<T>)를 기반으로 하는 양방향 데이터 바인딩을 통해 발생합니다. 이러한 주석으로 덤 컴포넌트는 스마트 컴포넌트로부터 관련 데이터를 받거나 스마트 컴포넌트로 데이터를 전송합니다. 스마트 컴포넌트는 일반적으로 서비스나 퍼사드를 주입하고 데이터 흐름을 다룹니다. 관련 gist를 보시면 됩니다.

10.단방향 아키텍처 (프런트엔드 중심)...

이것은 주로 반응형 프로그래밍과 관련이 있습니다. 요즘 프런트엔드 프레임워크에서 데이터 흐름은 반응형으로 지속됩니다. 데이터는 한 방향으로만 흐르며 뷰 쪽으로 향합니다. 뷰는 다양한 작업을 활성화합니다. 이를 통해 데이터에 대한 더 나은 제어가 가능해집니다. RxJs, NgRx, Flux와 같은 다양한 라이브러리는 데이터 스트림을 사용할 때 다양한 기능을 제공합니다.

여기에서 찾을 수 있는 다른 클라우드 네이티브 패턴이 많이 있습니다.

<div class="content-ad"></div>

만약 소프트웨어 엔지니어링 주제에 더 관심이 있다면 다른 글도 살펴보세요.

관련 글:

- Java Core Libraries에서 사용되는 10가지 소프트웨어 디자인 패턴
- 비교를 통한 메시지 큐 및 이벤트 스트리밍 제공 업체
- 소프트웨어 개발에서의 문서화 방식
- Spring Boot 애플리케이션에 SOLID 소프트웨어 디자인 원칙 적용하는 방법
- 반드시 알아야 할 Kubernetes 명령어의 궁극적인 목록

P.S. 트위터나 링크드인에서 저와 연락할 수 있어요.