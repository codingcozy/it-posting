---
title: "Nodejs에서 리소스 최적화 하는 방법"
description: ""
coverImage: "/assets/img/2024-07-07-ResourceoptimizationinNodejs_0.png"
date: 2024-07-07 23:11
ogImage:
  url: /assets/img/2024-07-07-ResourceoptimizationinNodejs_0.png
tag: Tech
originalTitle: "Resource optimization in Node.js"
link: "https://medium.com/pipedrive-engineering/resource-optimization-in-node-js-c90c731f9df4"
isUpdated: true
---

이 기사에서는 Node.js의 능력을 극대화하고 리소스 공유의 이점을 이해하여 모든 요청을 격리시켜야 한다는 가정을 반박합니다. Node.js의 모든 잠재력을 발견하고 리소스 최적화가 어떻게 애플리케이션의 성능과 효율성을 향상시킬 수 있는지 알아봅시다.

우리 모두가 Node.js가 빠르고 싱글 스레드이며 논블로킹이라는 것을 알고 있지만, 우리는 그것을 최대로 활용하고 있습니까? 대부분의 경우에 대답은 단순히 "아니요"입니다.

싱글 스레드이기 때문에 여전히 스레드와 비슷한 실행 라인이 여러 개 있다는 것을 잊어버립니다! 따라서 우리는 코드 실행 방식을 개선하여 얻은 리소스를 다른 사람에게 제공함으로써 소중한 리소스의 부하를 줄일 수 있습니다.

![](/assets/img/2024-07-07-리소스최적화_0.png)

<div class="content-ad"></div>

한 API를 호출하는 엔드포인트가 동시에 여러 고객에 의해 호출된다고 상상해 봅시다. 따라서 데이터가 필요한 요청이 도착하여 해당 API를 호출하면 이미 대기 중인 첫 번째 요청과 정확히 동일한 API를 호출하는 두 번째 요청이 도착한다면, 그것을 공유하지 않을 이유가 무엇이죠?
개발자들은 종종 Node.js 서버 작업 중에 각 요청이 다른 요청과 완전히 격리되어야 하며 각각은 나머지로부터 격리된 상태에서 호출하고 데이터베이스 요청을 수행해야 한다는 잘못된 가정을 만듭니다.

이는 단순히 사실이 아닙니다.

일부 조건이 충족되면 요청은 동일한 리소스를 공유할 수 있습니다.

<div class="content-ad"></div>

- 고객별 데이터가 아니거나 고객 인증 토큰을 사용하지 않는 것을 확인했습니다(모든 요청을 연결해서는 안 됩니다. 누가 요청을 보냈는지 알아야 하는 책임성 때문입니다).
- 요청 데이터가 정확히 동일합니다.
- 오류가 발생할 경우, 기타 고객에게 정보가 누설되지 않도록합니다 (GDPR 문제를 일으킬 수 있으므로) 모든 대기 중인 약속에 일반 오류를 발생시키고 원래 오류를 로깅하여 방지할 수 있습니다.
- 마지막으로, 여러 사용자 요청에 대해 리소스 공유가 유익하다고 입증된 자주 발생하는 호출이어야 합니다. 그렇지 않으면 이점이 거의 눈에 띄지 않을 것입니다.

요청이 어떻게 흘러가는지는 아래 그래프를 확인해주시면 됩니다. 각 행이 요청을 나타내고 각 색상 막대가 리소스를 사용하는 데 소요된 시간을 나타냅니다. 각 요청이 완전히 독립적이기 때문에 리소스를 공유하고 있지 않습니다. 이는 수천 개의 동시 요청을 처리하는 애플리케이션에서 중요한 문제로, 쉽게 해결하기 어려운 문제입니다.

<img src="/assets/img/2024-07-07-ResourceoptimizationinNodejs_1.png" />

매우 특화된 서비스가 있는 경우 동일한 리소스를 요청하는 여러 요청이 있을 수 있습니다. 이는 우리 애플리케이션을 개선할 수 있는 기회입니다.

<div class="content-ad"></div>

아래에서 알 수 있듯이 일부 호출이 Promises로 대체되었습니다. 이는 이미 가져온 동일한 리소스가 있기 때문에 다시 호출하는 대신 공유하기로 결정했기 때문입니다. 이는 해당 리소스에 대한 부하를 줄입니다.

![이미지](/assets/img/2024-07-07-ResourceoptimizationinNodejs_2.png)

Java와 같은 언어에서 개발자들은 리소스 액세스를 제어하기 위해 동기화된 메서드를 사용합니다. Node.js의 장점은 시스템 호출을 하지 않아도 되는데, 이는 비용이 많이 드는 뮤텍스나 세마포어를 작성할 필요가 없기 때문입니다. Node.js의 구조 때문에 심지어 더 빠르게 작동합니다.

물론 이 예에서는 서비스의 단일 인스턴스에 대해 언급했습니다. 서비스의 여러 인스턴스에서 이 작업을 수행하는 것은 조금 더 복잡하지만, 개념은 유사합니다(더 고급 분산 패턴 작업 중입니다).

<div class="content-ad"></div>

이 주제에 대해 흥미로운 점은 자원을 절약하는 것뿐만 아니라 실제로 애플리케이션을 더 빠르게 만든다는 것입니다. "어떻게?"라고 묻는다면? 우리가 한 작업이 200밀리초가 걸린다고 상상해 보겠습니다. 그리고 그 작업에 대한 이후의 모든 요청은 그것을 재사용합니다. 이는 이 초기 작업의 시작 후 1밀리초 또는 200밀리초 후 시작하는 경우에도 이 200밀리초 동안 수신되는 모든 요청이 해당 결과를 재사용한다는 것을 의미합니다. 따라서 평균적으로 재사용된 작업은 200밀리초/2=100밀리초가 걸립니다.

진행 중인 작업을 재사용함으로써 원래 작업 시간의 절반을 평균적으로 절약할 수 있습니다. 이것은 정말 대단한 이득입니다.

거래와 유사한 작업 범위 내에서 실행하거나 특정 사용자 토큰을 사용하는 API 호출을 수행하지 않는 한 (그 경우에는 생성된 데이터를 공유해서는 안 됩니다), 일반 작업의 상당 부분에서 데이터를 공유할 수 있고 어떠한 걱정도 없이 사용할 수 있습니다.

![자원 최적화](/assets/img/2024-07-07-ResourceoptimizationinNodejs_3.png)

<div class="content-ad"></div>

어떻게 이룰 수 있을까요? 약속이 해답입니다!!!

특정 리소스에 대한 호출이 이미 시작되었다는 것을 감지하면, 다시 호출을 시작하는 대신 해당 결과(또는 실패)에 대한 Promise를 반환합니다. 이렇게 함으로써 API, 데이터베이스 쿼리 또는 호출해야 하는 기타 것들에 대한 동시 요청을 피할 수 있어 리소스 부하를 줄일 수 있습니다.

시간이 좀 걸리는 호출을 수행하고 결과를 반환하는 간단한 호출을 구현해 봅시다. 이를 위해 몇 가지 값들을 200ms의 지연과 함께 곱하는 간단한 호출을 만들어 API 호출 또는 데이터베이스 쿼리를 대신할 것입니다:

이 코드를 실행하면 예상대로 결과를 얻게 됩니다. 함수를 6번 호출하고 각 호출에 200ms를 기다렸습니다.

<div class="content-ad"></div>

<img src="/assets/img/2024-07-07-ResourceoptimizationinNodejs_4.png" />

지금, 우리 어플리케이션을 개선하기 위해 이 패턴을 활용하도록 정확히 동일한 코드를 바꿔보겠습니다. 이번에는 호출 관리를 위해 OperationRegistry 클래스를 사용하고, 무엇보다 우리는 레지스트리에서 운영을 식별하기 위한 고유한 키를 생성할 것입니다.

이 작업이 완료되면, isExecuting 함수를 호출하여 Promise를 반환하는지 확인합니다. 만약 Promise를 반환한다면, 이는 다른 실행이 이미 진행 중이라는 의미이므로 결과를 기다리는 Promise를 반환하기만 하면 됩니다. 그렇지 않으면, 호출을 수행하고 결과를 보류 중인 모든 Promises에 전파하고 값을 반환합니다. 보류 중인 Promises에 결과를 전달하기 위해 우리는 작업이 성공했는지 여부에 따라 triggerAwaitingResolves 또는 triggerAwaitingRejects 함수를 사용합니다.

이 코드를 두 번째로 실행했을 때 어떤 일이 발생하는지 확인해보겠습니다:

<div class="content-ad"></div>

![이미지](/assets/img/2024-07-07-ResourceoptimizationinNodejs_5.png)

결과는 정확히 똑같지만, 우리 함수는 초기 6번이 아니라 고유한 키마다 한 번씩 호출되었습니다. 물론, 이 패턴은 동일한 작업을 여러 번 수행해야 유용할 것입니다. 왜냐하면 작업이 너무 많은 시간이 걸리거나 자주 발생하기 때문입니다.

하지만 주의할 점이 있습니다: 오류와 결과는 모든 실행에서 공유되므로 공유된 결과를 마음대로 변경하지 않도록 주의해야 합니다. 그렇지 않으면 예기치 못한 버그가 발생할 수 있습니다. 필요하다면 객체를 복제하는 것을 잊지 마세요.

요약:

<div class="content-ad"></div>

- 비록 이것이 항상 간단한 문제는 아니지만, 동시에 실행되는 애플리케이션에게는 중요한 차이를 만들어냅니다. 왜냐하면 리소스는 매우 소중한 자원이기 때문입니다. 더군다나, 이 기사에서 설명한 대로, 이는 리소스를 해방시키는 것뿐만 아니라 응용 프로그램 실행 시간을 개선시킵니다.
- 이는 자주 호출되는 작업에 엄청난 영향을 미치지만, 더 중요한 것은 리소스를 절약하고 시스템의 안정성을 향상시킨다는 점입니다. 조금이라도 이득을 보는 것은 P99 응답 시간을 줄이는 데 도움이 되며, 이는 매우 중요합니다.
- 이에 캐시를 추가하면 더욱 좋습니다! 한 인스턴스에서 리소스를 절약하는 대신, 서비스의 모든 인스턴스를 대상으로 이 리소스를 저장할 수 있다면 상상해보세요. 왜냐하면 그럼 여러 인스턴스에 걸쳐 공통 리소스에 더 자주 접근할 수 있기 때문입니다.
- 이런 작은 세부 사항들이 잘 만들어진 마이크로서비스 아키텍처와 구현이 잘못된 것을 구분짓게 합니다. 왜냐하면 CPU 성능과 메모리만으로는 모든 것을 해결할 수 없으며 최적화된 서비스를 갖는 것이 승자와 패자를 구분짓는 것입니다.

이 문서의 권고사항에 따른 결과를 공유해 주시기 바랍니다.

자료:
https://www.npmjs.com/package/reliable-caching
