---
title: "프로그래밍 필수 원칙 KISS Keep It Simple, Stupid 원칙의 모든 것"
description: ""
coverImage: "/assets/no-image.jpg"
date: 2024-07-18 11:38
ogImage:
  url: /assets/no-image.jpg
tag: Tech
originalTitle: "KISS, The Only Software Design Principle You Need"
link: "https://medium.com/gitconnected/kiss-the-only-software-design-principle-you-need-ae61b11cd7c6"
isUpdated: true
---

당신은 미리 예상하는 테이블태그 변경이 필요했나요? 좋아요, 아래와 같이 변경해 볼게요.

| 본문 | 여기를 작성하세요 |
| ---- | ----------------- |
| 행 1 | 내용 1            |
| 행 2 | 내용 2            |

<div class="content-ad"></div>

## 다른 원칙들이 완전히 맞지 않는 이유

가치 있는 간단함에 대한 이야기에 들어가기 전에, 복잡성을 이해하고 다른 원칙들이 그것을 효과적으로 다루지 못하는 이유에 대해 이해하는 것이 중요합니다.

"DRY(Don't Repeat Yourself)"는 대부분의 개발자들이 매우 이른 시기에 만나는 디자인 원리로, 함수 작성이나 루프 작성을 배우는 것만큼 일찍 소개되지요. 그리고 이것은 소프트웨어 개발 경력의 초보자일 때에도 말이 되죠. 심지어 DRY에 초점을 맞춘 풀 리퀘스트는 리뷰어에게 감사히 받아들여지고, 그 사람이 정말 무엇을 하는지 알고 있는 것처럼 느끼게 할 수도 있습니다.

그러나 DRY은 우리가 Angular, Vue 또는 React와 같은 솔루션을 사용해 아주 기본적인 웹사이트를 구축하는 사람들이 있는 이유, 왜 우리가 너무 많은 일을 하는 슈퍼컴포넌트가 있고 우리가 그것을 손 대면 매번 망가뜨리는 이유, 그리고 '풀 수 없는' 종속성이나 누구도 알지 못하는 도움 함수들이 코드베이스 주변에 흩어져 있는 이유가 되기도 합니다. DRY는 간단함을 보장하지 않습니다. 오히려, 복잡성과 지나친 엔지니어링의 가능성을 더 높일 수도 있습니다. 믿거나 말거나, 중복은 지나친 추상화보다 더 나은 악이지요. 하지만 이에 대해서는 전용 섹션에서 다시 다뤄보겠습니다. 중복을 사용하면 IDE나 find-replace 문자열 검색 기능을 사용하여 문제를 해결할 수 있지만, 너무 DRY한 코드는 혼자서 해결해야 합니다.

<div class="content-ad"></div>

SOLID은 인기가 있지만, 객체 지향 프로그래밍 때문에 그렇다고 생각합니다. 사실, SOLID가 번들로 묶는 모든 원칙은 객체 지향 프로그래밍에 특정 도전 과제를 해결하기 위한 것입니다. 좀 더 빈티감있는 사람은 마지막 문장에서 나타나는 두 가지 주요 문제에 대해 암시하고 있는 것을 알아차릴 것입니다: 그 기원과 원칙의 모음이라는 점입니다. 다음 소프트웨어 엔지니어링 모임에서 무작위로 사람들에게 SOLID가 무엇을 의미하는지 물어보면, 모두다 5가지 원칙을 모두 이야기하는 사람이 있더라도 10명 중 3명밖에 찾기 어려울 것입니다: 단일 책임, 개방 폐쇄, 리스코프 치환, 인터페이스 분리, 의존성 역전.

SOLID가 실제로 무엇을 의미하는지 기억하는 사람이 하드코어 OOP 팬을 제외하고 거의 아무도 없다는 점은 놀라운 일이 아닙니다. 제가 모르는 사람들을 탓할 수 없습니다. 그것은 그냥 너무 과학적이며, 프로그래밍의 컴퓨터 과학 측면에 흥미를 느끼지 않는 소프트웨어 엔지니어가 더 많기 때문입니다. 오히려 무엇을 실제로 구축할 수 있는지나 — 솔직히 말하면 — 하루의 끝에 상당한 보수를 받을 수 있는지에 더 관심이 있습니다.

그리고 물론 OOP 문제도 있습니다. OOP가 이미 소프트웨어 엔지니어들 사이에서 이미 논란이 많았는데, 이제 함수형 프로그래밍 팬들이 이 문맥에서 SOLID가 의미가 있는지에 대해 논의하고 있습니다. 모든 것이 아주 빠르게 매우 학문적으로 변합니다. 제 개인적인 의견으로는 Scott Wlaschin의 10년 전 FP 발표에서 동의하는 편입니다. OOP 원칙이 FP에 직접적인 동등물이 없다고 말하고 있으며, 그래서 SOLID가 FP에 적용될 수 없습니다. 비록 일반적인 프로그래밍 개념으로, 아마 FP 틀에 맞춰 집어넣을 수 있을 것입니다.

이제 PoLA로 넘어가 봅시다. "가장 놀랍지 않은 원칙"을 의미하는 PoLA는 60년대에 만들어진 것으로 알려져 있습니다. 이것은 소프트웨어 개발에서 훨씬 덜 알려진 원칙이며, 이것은 웹 접근성 전문가로서 조언을 하고 있는 UX 회의에서 발견한 마지막 것입니다 — 믿을 수 없겠지만요. 일부 장애를 가진 개인들이 UX 동작을 매우 예상치 못하게 느끼게 한다는 점에 대한 주장을 할 때, 한 명의 시니어 UX 디자이너가 "오! 가장 놀랍지 않은 원칙. 이해가 됩니다."라고 말했습니다. 이것은 궁극적으로 예상치 않는 일을 하지 않으려는 간단한 원칙입니다. 미리 설정된 패턴을 따르고, 시스템 외부로 나가지 말고, 기대를 깨지 말고, 사고 모델을 존중하세요. 상당히 자명한 것 같습니다.

<div class="content-ad"></div>

나는 유용한 원칙이라는 점에 동의할 것이다. 그러나 효과가 제한적이며 나쁜 패턴을 장려할 수 있는 점도 있을 거라고 생각해. frontend 애플리케이션의 대형 monorepo를 상상해봐. 여기서 각 애플리케이션이 API 통신에 Axios를 사용하고 있는 상황이야. 이러한 패턴을 보고 PoLA 원칙에 기반하여 단순한 네이티브 fetch만 필요하다고 해도, PR을 제출할 때, 리뷰어들이 "뭐야?!? Axios를 사용하는데 너는 fetch를 왜 사용하고 있어?" 라고 할 수도 있어. 전쟁처럼 소란이 벌어진 뒤에야 Axios가 정말로 필요하지 않았다는 것을 깨닫게 될 거야. Axios는 단지 처음에는 인기 있었기 때문에 사용되었고 "나중에 필요할지도 모르니까" 라는 이유로만 사용되었던 거지, 이제 그 패턴은 별 의미가 없는 패턴으로 남게 됐어. PoLA 원칙은 유용하고 쉽게 기억될 수 있지만, 전체적인 효과에 대해 의문을 품을 수도 있어.

그리고 필요 없을 것 같은 것에 대해 얘기해볼게. YAGNI에 대해 빼놓을 수 없지. 이것은 Agile 조직에서 매우 인기 있는 원칙이야. 누군가는 이것이 Agile을 위해 만들어진 거라고 할 수도 있을 정도야. 그것이 사실이든 아니든, 이것은 익스트림 프로그래밍 원칙이고 나는 가끔 이것을 언급하며 대화를 할 때 종종 다루곤 해. 이것은 일을 생성발전할 때 비난 점을 강조하려고 하는 나로서는 자연스럽게 발생하는 것이야. YAGNI가 복잡성을 줄이는 필요를 표현하는 데 아마도 가장 가까운 원칙일지라도, 그 메시지를 제대로 전달하지 못하는 거 같아. 항상 제품 디자인 원칙보다는 소프트웨어 디자인 원칙이라기보다 제품 디자인 원칙으로 느껴질 거야. 네, 이것은 아키텍처 또는 더 세부적인 결정에도 적용할 수 있겠지. 예를 들어, 앱에 moment.js가 진짜 필요한 건가? 앞으로 그것이 필요할 것이라고 생각하는 게 현실적인가? 스위치 문 대신 if-else문을 작성해야 되는지? Scala 마이크로서비스에 akka가 적합한 선택일까? YAGNI를 기억하면 올바른 결정을 내릴 수 있지만, KISS만큼 소프트웨어 공학을 종합적으로 다루지는 못한다. 하지만 KISS를 좋아하거나 그 이유가 있을 경우, 꽤 괜찮은 대안일 수도 있어 — 그 이니셜이 조금 재미있다는 건 알지만. 😄

관심사의 분리(SoC)는 경력 초창기에 많이 언급되는 원칙 중 하나야, 특히 기술 회사에서 일을 하게 되면 말이지 — 웹 디자인 에이전시에서는 그렇게 많이 언급되지 않아. 내가 그것을 설명해야 할 때는 항상 이렇게 이야기해:

덜 웃기지만 여전히 흥미로운 예로는 각 주요 기능이 별도의 앱인 마이크로 프론트엔드예요. 그것을 더 세분화하면 함수까지 들어갈 수 있어요. 대부분의 함수형 프로그래머들은 함수가 단일 책임을 가져야 한다는 것에 꽤 엄격할 거야 — 그게 SOLID의 S야 — 그리고 그것은 단일 파라미터를 갖는 함수로 변환될 거야. F# 또는 Haskell과 같은 특정 언어는 자동으로 이를 커링으로 처리할 거야. 하지만 나는 이 자리에서 멀어지고 있네. 이곳의 교훈은 관심사의 분리가 모듈화, 가독성 및 재사용성을 도와줌으로써, 소프트웨어 개발자의 삶을 훨씬 쉽게 만든다는 거지. 이상적으로는, 그렇지요.

<div class="content-ad"></div>

현실적으로 SoC를 염두에 두고 애플리케이션을 작성한 것을 아직은 보지 못했습니다. 마이크로프론트엔드 예시로 돌아와서, 주요 기능을 위한 구별된 앱이 있어도 그 앱의 핵심이 스파게티처럼 보이는 것은 아닙니다. 식재료로는 맛있게 들릴 수 있지만, 코드로는 훨씬 덜 바람직합니다. 안타깝게도, 여러 가지 이유(많은 것들이 합리적인 이유일 수 있음)로 우리 엔지니어들은 결국 포기하고 모든 것이 작동하도록 코드를 던져 넣기 시작하고 결과적으로는 스파게티 미트볼을 닮은 무언가와 같은 것을 얻게 됩니다.

## 추상화 강박증

StackOverflow에서 10분 이상을 보낼 필요가 없다고 생각합니다. "한 줄로 할 수 있어"라는 자랑스러운 답변을 볼 수 있습니다. 공정하게 말하자면, 그 일줄짜리 코드 중 일부는 좋은 제안뿐만 아니라 파괴 분해 구문과 같은 것이심지어 React에 의해 극도로 인기를 얻기도 합니다. const ' name, age, location ' = user; 이 같은 경우는 대안이 지나치게 상세할 수 있기 때문에 너무 많은 것을 담지 않는다. 그러나 많은 한 줄짜리 코드는 지나치게 상세한 코드를 해결하려는 시도가 아니라 추상화 연습을 위한 것입니다.

코드를 더 적게 사용하여 프로그래밍 과제를 해결하려는 선의의 의도로 추상화는 해결이 간단하지 않게 만들 수 있는 여러 문제를 만들어낼 수 있습니다. 이를 **추상화 과부하** 라고 합니다. 문제를 해결하는 대신 더 많은 문제를 만들어내게 됩니다:

<div class="content-ad"></div>

- 추가적인 인지적 부담. 고도로 추상적인 코드를 작성하는 것은 상대적으로 쉽습니다. 왜냐하면 코드가 위치할 맥락을 이미 알고 있기 때문에 가장 중점을 둘 부분은 한 줄밖에 없기 때문입니다. 그러나 수개월 혹은 몇 년 후에 코드를 읽을 때, 프로그램을 몇 분 내로 이해하는 대신, 다른 엔지니어는 여러분의 한 줄로 뭘 달성하려고 했는지 찾아야 합니다. 그 사람이 아마 여러분일 수도 있습니다.
- 과도하게 부서지기 쉬운 코드. 우리 스스로를 속이지 말아요. 우리는 코드를 작성하고 10년간 방치하지 않는다구요. 근본적인 요구사항과 사용 사례가 변하기 때문에 유지 보수가 어려운 코드베이스에 자리 잡게 될 수 있습니다. 한 가지 요구사항을 변경하는 것이 예상치 못한 결과를 나타내기 때문입니다.
- 대부분 불필요한 것. 웹에서 x, y 또는 z와 같은 추상적 변수 이름을 주장하는 사람들을 볼 때마다, 나는 그들이 축소화(minification)에 대해 들어본 적이 있는지 궁금해집니다. 단일 문자 변수를 사용하도록 엔지니어들을 유도하도록 강요하는 건 하루 속히 있는 미신입니다. 사실, 구글 자체의 JS/TS 스타일 가이드는 대부분 단일 문자 변수 사용을 금합니다.
- 코드 부풀리기. 기술적으로 모든 코드는 추상화될 수 있습니다. 사실상, 많은 부분이 그렇게 되어서는 안 됩니다. 어떤 것이 재사용 가능하게 만들어질 수 있다고 해도 반드시 필요한 것은 아니죠. 결과적으로 필요 이상으로 재사용 가능한 코드 덩어리들이 생성되어, 전체적으로 이전보다 무겁게된 코드 베이스가 나타나게 됩니다.

모든 것이 과하면 좋지 않으며, 이는 코드 추상화에도 똑같이 적용됩니다. 그것은 단순히 취향이나 코더 성격 특징에만 해당되는 것이 아닙니다. 프로그램과 개발자 경험을 단순화하는 대신에 복잡하게 만들어 작업하기가 훨씬 어렵게 만드는 노력이 불필요하거나 돈과 시간을 낭비하는 매우 의식적인 결정입니다. 그 후 결국, KISS로 이르게 됩니다.

## 단순함이 신비롭다

모든 다른 유명한 소프트웨어 디자인 원리와 연관이 있는 모든 관련 맥락을 고려하면 단숨함의 가치를 매우 쉽게 이해할 수 있습니다. 일부 사람들이 생각하는 것과는 반대로, 코드, 소프트웨어 아키텍처, 심지어 제품에서의 단순함은 평범함을 의미하지 않습니다. Dieter Rams, Steve Jobs, Albert Einstein, Dr. Seuss 및 기타 많은 사람들이 복잡함 대신 단순함을 장려해 왔습니다. Antoine de Saint-Exupéry가 유명하게 말한 것처럼:

<div class="content-ad"></div>

시인의 말 한 줄이라도 소프트웨어 엔지니어링을 정확하게 설명할 수 있다는 건 웃기죠. 주니어 소프트웨어 개발자가 하는 실수 중 하나는 코딩한 줄 수가 많을수록 해결책이 복잡해 보이고 더 좋은 엔지니어라고 착각하는 것입니다. 실제로 그렇지 않은 경우가 훨씬 많고, 맞는 경우라 해도 이전의 부주의나 설계 실수 때문이며, 모든 것을 리팩토링하지 않는 한 이미 복잡한 문제에 추가로 동작을 쌓아야 하는 상황은 드뭅니다. 우리 모두 다 경험이 있죠, 가장 중요한 건 그 사실을 인정하는 것이죠.

Agile Planning Poker에서 낮은 점수를 준 사람들의 의견에 항상 관심을 가지곤 합니다. 보통 작업의 시간 복잡성을 과소평가하거나, 가장 단순하고 현실적인 해결책을 생각하는 KISS 마인드 엔지니어가 있는 경우일 때가 많습니다. 어떤 면에서는 KISS가 애자일에 내재된 것으로 볼 수도 있습니다. "Keep it simple, stupid"는 "최소한의 실행 가능 제품"과 거의 같은 의미를 갖고 있습니다. KISS는 코드를 제품 기능처럼 생각하도록 권장합니다. 과도한 투자를 하지 말고 너무 일찍 최적화에 빠지지 말고, 중요한 것에 집중하며, 한 번 생각해 보면 KISS가 다른 소프트웨어 설계 원칙들을 매우 적절하게 설명한다는 걸 깨달을 수 있습니다.

- DRY — 불필요하게 반복하지 않지만 과도하게 DRY해지거나 추가 복잡성을 더하지 않습니다.
- SOLID — 객체지향 프로그래밍, 함수형 프로그래밍, 절차적, 명령형 또는 선언적 프로그래밍의 최고의 실천 방법을 우연히 따를 것이며, JavaScript나 Python과 같은 다중 패러다임 언어에서는 단순히 TASK에 기반해서 SOLID가 적용되는지 여부에 대한 강한 의견보다는 하나의 패러다임을 선택하는 데 중점을 둘 것입니다.
- PoLA — 코드에서 예상하지 못한 작업을 수행할 경우 불필요한 복잡성이나 최소한의 인지 부담이 생길 수 있습니다.
- YAGNI — 미래에 필요하지 않은 것을 추가할 이유가 없습니다. 그렇게 하면 문제를 간단하게 유지하지 못하게 됩니다.
- SoC — 코드에서 관심사를 분리하기 위해 노력할 것입니다. 덜 할수록 코드는 더 불필요하게 복잡해질 것입니다.

이것은 정말 강력한 것 같습니다. 여러 해 동안 소프트웨어 설계 원칙이 적용되는 단계를 보여주는 다이어그램이 만들어졌습니다. 모든 것이 YAGNI로 시작해서 KISS로 이어지며 DRY로 마무리되는 경향이 있다고 알려져 있죠. 일반적인 관점 중 하나는 YAGNI가 제품 수준에서, KISS가 기능 수준에서, 그리고 DRY가 코드 수준에서 적용된다는 것입니다. 저는 그 관점에 도전하고 싶습니다.

<div class="content-ad"></div>

KISS는 모든 수준에서 적용될 수 있다고 생각해요. 사실, 모든 소프트웨어 설계 원칙이 모든 수준에서 적용될 수 있어요. 다른 점은 KISS가 모두 대신하고 어떤 것을, 왜 적용해야 하는지와 언제 적용해야 하는지에 대한 학술적인 대화의 필요성을 제거할 수 있다는 것이에요. 우리는 그냥 KISS만으로도 충분한 현실적 프로그래밍 원칙이라고 부를까요?

## 비즈니스 현실

마지막에는 KISS를 핵심 소프트웨어 공학 원칙으로 고수해야 하는지 여부에 동의하든 말든 중요하지 않아요. 다른 원칙을 기억하고 적용하면 똑같이 잘 지원받을 거예요. 그러나 우리 모두가 무시할 수 없는 현실은, 이러한 원칙들이 존재해야 하는 비즈니스 맥락이 더 자주 존재한다는 것이에요.

전반적인 엔지니어링 조직에서 볼 때, 복잡성을 줄이고 실제로 중요한 측면에 초점을 맞추며 수익을 창출하는 솔루션을 전달하려는 열망이 늘어나고 있다고 봐요. 그렇게 하려면 과거의 결정을 살펴보고 충분한 실용주의와 객관성을 가지고 그것들을 분석하여 어떤 선택이 단순함을 염두에 두지 않고 내렸는지 인정해야 하는 복잡한 도전이 될 겁니다. 아마도 그 선택들은 어떠한 원칙에도 따르지 않는다고 해도요. 그러나 현실은, 지금 당신은 그것을 해야 하고, 어제의 실수를 수정하거나 5년 전에 잘 작동했던 것이 더 이상 작동하지 않는다는 것을 인정하는 것은 쉽지 않지만, 효율적으로 운영되는 소프트웨어 조직을 위해 절대적으로 필수적인 요구 사항이에요.

<div class="content-ad"></div>

진실은, 심지어 최고 수준의 엔지니어링팀도 간소화할 기회를 찾게 될 것입니다, 복잡성을 줄일 수 있는 기회를 찾을 것입니다. 아마도 유지하기 어려운 거대한 코드 덩어리와 작업 중이실지 모릅니다. 아니면, 마이크로서비스 또는 마이크로프론트엔드를 고려할 때가 됐을지도 모릅니다. 하지만 실제로 필요한 것은 간단함과 모듈성을 달성하기 위해 관심 분리가 조금 필요할 수도 있습니다. 유감스럽게도 많은 노력이 불편한 스택으로 인해 기인할 수 있다는 것을 발견할 수도 있습니다. 그런 경우 합치는 것이 좋을지도 모릅니다. 리액트 - 장고 - 스칼라 - SQL 몬스터를 계속 자라나는 여분의 머리를 가진 것에서 MERN이나 MEAN 스택으로 이동하는 것도 좋은 방법일 수 있습니다. 심지어 스택 중 일부는 직접 개발된 솔루션이 아니어야 할 수도 있습니다. 때로는 직접 만드는 것보다 구매하는 것이 더 나은 선택일 수 있습니다.

이 모든 결정을 내릴 수 있는 것은 언제든지 KISS를 염두에 둔 채로 가능합니다. 개발 전, 중, 후일지라도 KISS는 환상적인 범용 소프트웨어 엔지니어링 원칙이며, 진정으로 미래에 나쁜 소프트웨어를 빨리 떠날 수 있도록 우리 모두가 근본적인 기억으로 만들어야 하는 유일한 원칙이라고 믿습니다.😉

Attila Vago - 시간마다 세상을 개선하는 소프트웨어 엔지니어. 영원한 재밌는 주주, 코드, 블로그, 책 작가. 저자. 웹 접근성 옹호자, 레고 팬, 레코드 수집가. 핸드크래프트 맥주를 사랑합니다! 여기서 제 Hello 이야기를 읽어보세요! LEGO, 기술, 코딩 및 접근성에 대한 이야기를 더 구독하세요! 가끔 읽는 독자들을 위해, 제 랜덤한 이야기와 글쓰기에 대해도 씁니다.
